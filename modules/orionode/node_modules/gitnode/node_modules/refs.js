/*******************************************************************************
 * Module for managing refs directory in git repositiry
 * Version: Test/Alpha
 ******************************************************************************/

var fs = require('fs');
var packedRefs = require('packedRefs');

/**
 * Constructor for Refs object
 * @param path path to .git folder
 * @param callback callback(err)
 */
function Refs(path, callback) {
    this.path = path;
    this.packedRefsManager = new packedRefs.PackedRefs(this.path,
        function(err) {
        if (err) {
            callback(err);
            return;
        }
        var refsObject = this;
        fs.mkdir(this.path + '/refs', 0777, function () {
            fs.mkdir(refsObject.path + '/refs/heads', 0777, function () {
                fs.mkdir(refsObject.path + '/refs/tags', 0777, function () {
                    callback('');
                    return;
                });
            });
        });
    });   
}

/**
 * Creates branch
 * @param name name of the branch
 * @param SHA_1 value connected with branch
 * @param callback callback(err)
 */
Refs.prototype.createBranch = function (name, SHA_1, callback) {
    fs.writeFile(this.path + '/refs/heads/' + name, SHA_1, function (err) {
        if (err) {
            callback(err);
            return;
        }

        callback('');
        return;
    });
}

/**
 * Updates branch when branch exists and only SHA_1 is changing
 * @param name name of the branch
 * @param SHA_1 new SHA_1
 * @param callback callback(err)
 */
Refs.prototype.updateBranch = function (name, SHA_1, callback) {
    fs.writeFile(this.path + '/refs/heads/' + name, SHA_1, function (err) {
        if (err) {
            callback(err);
            return;
        }

        callback('');
        return;
    });
}

/**
 * Makes new name for existing branch
 * @param nameOld current name of the branch
 * @param nameNew new name
 * @param callback callback(err)
 */
Refs.prototype.renameBranch = function (nameOld, nameNew, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/heads/' + nameOld, function (exists) {
        if (exists) {
            fs.rename(refsObject.path + '/refs/heads/' + nameOld,
                refsObject.path + '/refs/heads/' + nameNew, function () {
                    callback('');
                    return;
                });
        } else {
            callback('error: branch \'' + nameOld + '\' not found');
            return;
        }
    });
}

/**
 * Removes branch
 * @param name name of the branch
 * @param callback callback(err)
 */
Refs.prototype.removeBranch = function (name, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/heads/' + name, function (exists) {
        if (exists) {
            fs.unlink(refsObject.path + '/refs/heads/' + name, function () {
                callback('');
                return;
            });
        } else {
            callback('error: branch \'' + name + '\' not found');
            return;
        }
    });
}

/**
 * Gets all branches names
 * @param callback callback(err, names)
 */
Refs.prototype.getBranchesNames = function (callback) {
    var refsObject = this;
    fs.readdir(this.path + '/refs/heads/', function (err, files) {
        if (err) {
            callback(err, '');
            return;
        }
        refsObject.packedRefsManager.getBranchesNames(function(branches) {
            var branches = files.concat(branches);

            callback('', branches);
            return;
        });
    });
}

/**
 * Reads SHA_1 from .git/HEAD file
 * @param callback callback(err, SHA_1)
 */
Refs.prototype.getSHA_1OfTheActiveBranch = function(callback) {
    var refsObject = this;

    fs.readFile(this.path + '/HEAD', 'utf8', function (err, content) {
        if (err) {
            callback(err, '');
            return;
        }
        var lines = content.split('\n');
        callback('', lines[0]);
        return;
    });
}

/**
 * Uses SHA_1 and gets name of a branch, which has that one SHA_1
 * @param SHA_1 branch's SHA_1 
 * @param callback callback(err, x), where x == '' if there is not branch with
 * given SHA_1 and x is a name if there is a branch 
 */
Refs.prototype.getBranchNameUsingSHA_1 = function(SHA_1, callback) {
    var refsObject = this;
    var filesChecked = 0;
    fs.readdir(this.path + '/refs/heads/', function (err, branchesNames) {
        if (err) {
            callback(err, '');
            return;
        }
        for (index in branchesNames) {
            fs.readFile(refsObject.path + '/refs/heads/' + branchesNames[index],
                'utf8', function(err, content) {
                if (err) {
                    callback(err, '');
                    return;
                }

                if (SHA_1 == content.split('\n')[0]) {
                    callback('', branchesNames[index]);
                    return;
                }
                ++filesChecked;
                if (filesChecked == branchesNames.length) {
                    callback('', '');
                    return;
                }
            });
        }
    });
}

/**
 * Gets the name of active branch
 * @param callback callback(err, name)
 */ 
Refs.prototype.getActiveBranchName = function(callback) {
    var refsObject = this;

    refsObject.getSHA_1OfTheActiveBranch(function(err, activeBranchSHA_1) {
        if (err) {
            callback(err, '');
            return;
        }
        refsObject.getBranchNameUsingSHA_1(activeBranchSHA_1, function(name) {
            if (name == '') {
                refsObject.packedRefsManager.getBranchNameUsingSHA_1(
                    activeBranchSHA_1, function(name) {
                    callback('', name);
                    return;
                });
            } else {
                callback('', name);
                return;
            }
        });
    });
}

/**
 * Gets all branches names and next to each of them marks if this one
 * is active one
 * @param callback callback(err, structure)
 */
Refs.prototype.getBranchesNamesWithActiveMarks = function (callback) {
    var refsObject = this;
    this.getActiveBranchName(function(err, activeBranchName) {
        if (err) {
            callback(err, '');
            return;
        }
        refsObject.getBranchesNames(function(err, branchesNames){
            if (err) {
                callback(err, '');
                return;
            }
            var returnStructure = new Array();
            for (var index in branchesNames) {
                var branchStructure = new Array();
                if (branchesNames[index] == activeBranchName) {
                    branchStructure['active'] = true;
                } else {
                    branchStructure['active'] = false;
                }
                returnStructure[branchesNames[index]] = branchStructure;
            }
            callback('', returnStructure);
            return;
        });
    });
    
}

Refs.prototype.createTag = function (name, SHA_1, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/tags/' + name, function (exists) {
        if (exists) {
            callback('fatal: tag \'' + name + '\'already exists');
        }
        fs.writeFile(refsObject.path + '/refs/tags/' + name, SHA_1,
            function (err) {
                if (err) {
                    throw err;
                }

                callback();
            });
    });
}

Refs.prototype.removeTag = function (name, callback) {
    var refsObject = this;
    fs.exists(this.path + '/refs/tags/' + name, function (exists) {
        if (exists) {
            fs.unlink(refsObject.path + '/refs/tags/' + name, function () {
                callback();
            });
        }
        
        callback('error: tag \'' + nameOld + '\' not found');
    });
}

Refs.prototype.getTagsNames = function (callback) {
    fs.readdir(this.path + '/refs/tags/', function (err, files) {
        callback(files);
    });
}

/**
 * Packs refs folder to .git/packed-refs file
 * @param callback callback(err)
 */
Refs.prototype.packBranches = function(callback) {
    this.packedRefsManager.saveInFile(function(err) {
        if (err) {
            callback(err);
            return;
        }
        callback('');
        return;
    });
}

exports.Refs = Refs;